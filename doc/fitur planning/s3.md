# Linode S3 Object Storage Integration Plan

## Overview
Integrate Linode S3-compatible object storage to handle image uploads and migrate existing base64-encoded images to cloud storage. This will improve performance, reduce database size, and provide better scalability.

## Objectives
1. Set up Linode S3 bucket configuration
2. Create backend API endpoints for file uploads
3. Migrate existing base64 images to S3
4. Update frontend components to use S3 URLs
5. Implement automatic upload for new images

---

## S3 Configuration Details

**Bucket Name**: `customfly`  
**Endpoint**: `customfly.us-southeast-1.linodeobjects.com`  
**Region**: `us-southeast-1`  
**Access Key**: `SVKIVL647GUC6BZ05NPA`  
**Secret Key**: `uP1GUwlWd7tXL7rGS3TnvkCcZtVc7Kgnw2mU0Gid`

---

## Implementation Steps

### Phase 1: Backend Setup

#### 1.1 Install Dependencies
```bash
npm install @aws-sdk/client-s3 @aws-sdk/lib-storage multer --legacy-peer-deps
```

**Packages**:
- `@aws-sdk/client-s3`: AWS SDK for S3 operations
- `@aws-sdk/lib-storage`: Multipart upload support
- `multer`: Middleware for handling multipart/form-data

#### 1.2 Environment Configuration
Add to `/backend/.env`:
```env
# Linode S3 Configuration
S3_ENDPOINT=https://us-southeast-1.linodeobjects.com
S3_REGION=us-southeast-1
S3_BUCKET=customfly
S3_ACCESS_KEY=SVKIVL647GUC6BZ05NPA
S3_SECRET_KEY=uP1GUwlWd7tXL7rGS3TnvkCcZtVc7Kgnw2mU0Gid
S3_PUBLIC_URL=https://customfly.us-southeast-1.linodeobjects.com
```

#### 1.3 Create S3 Service Module
**File**: `/backend/services/s3Service.js`

**Features**:
- Initialize S3 client with Linode endpoint
- Upload file from buffer/stream
- Upload base64 string
- Delete file
- Generate public URL
- List files (for migration)

#### 1.4 Create Upload API Endpoints
**File**: `/backend/server.js` (add new routes)

**Endpoints**:
1. `POST /imcst_api/upload/image` - Upload single image
2. `POST /imcst_api/upload/base64` - Convert base64 to S3
3. `DELETE /imcst_api/upload/:key` - Delete image
4. `POST /imcst_api/migrate/images` - Migrate all base64 images

---

### Phase 2: Database Schema Updates

#### 2.1 Track Image Storage Location
**File**: `/backend/prisma/schema.prisma`

**Options**:
- Add `imageStorageType` field to relevant models (ENUM: 'base64', 's3', 'url')
- Add `s3Key` field to store S3 object key
- Keep backward compatibility with existing base64 data

**Models to Update**:
- `MerchantConfig` (variantBaseImages)
- `UserAsset` (value field for images)
- `Design` (designJson contains image references)

---

### Phase 3: Migration Strategy

#### 3.1 Identify Images to Migrate
**Sources**:
1. Variant base images in `MerchantConfig.variantBaseImages`
2. User uploaded images in `UserAsset` where type = 'image'
3. Design JSON containing base64 image data
4. Gallery images in `UserAsset` where type = 'gallery'

#### 3.2 Migration Script
**File**: `/backend/migrate_to_s3.cjs`

**Process**:
1. Query all records with base64 images
2. For each image:
   - Extract base64 data
   - Upload to S3 with organized folder structure
   - Get S3 URL
   - Update database record
   - Log migration status
3. Generate migration report
4. Keep base64 as backup (optional flag to delete)

**Folder Structure on S3**:
```
/variant-images/{productId}/{variantId}.jpg
/user-assets/{merchantId}/{assetId}.jpg
/gallery-images/{merchantId}/{galleryId}/{imageIndex}.jpg
/design-images/{designId}/{elementId}.jpg
```

---

### Phase 4: Frontend Updates

#### 4.1 Update Image Upload Components
**Files to Modify**:
- `/frontend/src/components/PublicCustomizationPanel.tsx`
- `/frontend/src/components/BaseImageModal.tsx`
- `/frontend/src/components/Toolbar.tsx` (image upload tool)

**Changes**:
- Replace FileReader base64 conversion with FormData upload
- Send file to `/imcst_api/upload/image` endpoint
- Receive S3 URL and update element
- Add upload progress indicator
- Handle upload errors

#### 4.2 Update Image Rendering Logic
**Files to Modify**:
- `/frontend/src/components/DesignerOpenCore.tsx`
- `/frontend/src/components/Canvas.tsx`

**Changes**:
- Remove base64 prefix fix (no longer needed)
- Images will be proper URLs from S3
- Add image loading states
- Add error fallback images

---

### Phase 5: Testing & Validation

#### 5.1 Unit Tests
- S3 service upload/delete operations
- Base64 to S3 conversion
- URL generation

#### 5.2 Integration Tests
- Upload via API endpoint
- Migration script dry-run
- Frontend upload flow

#### 5.3 Manual Testing Checklist
- [ ] Upload new variant base image
- [ ] Upload customer image in public designer
- [ ] Upload gallery images
- [ ] Verify images display correctly
- [ ] Test image deletion
- [ ] Verify migration of existing images
- [ ] Check S3 bucket permissions (public read)

---

### Phase 6: Deployment

#### 6.1 Pre-Deployment
1. Backup database
2. Test migration script on staging/copy
3. Verify S3 bucket is created and configured
4. Set bucket policy for public read access

#### 6.2 Deployment Steps
1. Deploy backend with S3 service
2. Run migration script
3. Deploy frontend with updated upload logic
4. Monitor error logs
5. Verify all images loading correctly

#### 6.3 Rollback Plan
- Keep base64 data in database for 30 days
- Can revert frontend to use base64 if S3 fails
- Database backup allows full restoration

---

## File Organization

### New Files to Create
```
/backend/services/s3Service.js          # S3 operations service
/backend/migrate_to_s3.cjs              # Migration script
/backend/routes/uploadRoutes.js         # Upload API routes (optional)
/doc/s3-integration.md                  # Documentation
```

### Files to Modify
```
/backend/.env                           # Add S3 credentials
/backend/package.json                   # Add dependencies
/backend/server.js                      # Add upload routes
/backend/prisma/schema.prisma           # Track storage type (optional)
/frontend/src/components/PublicCustomizationPanel.tsx
/frontend/src/components/BaseImageModal.tsx
/frontend/src/components/DesignerOpenCore.tsx
```

---

## Security Considerations

1. **Access Control**:
   - Use IAM-like policies on Linode bucket
   - Only allow uploads from authenticated admin users
   - Public read access for images

2. **File Validation**:
   - Validate file type (images only)
   - Limit file size (e.g., 10MB max)
   - Sanitize filenames
   - Generate unique keys to prevent overwrites

3. **Credentials**:
   - Store in `.env` file (not in git)
   - Use environment variables in production
   - Rotate keys periodically

4. **CORS Configuration**:
   - Configure bucket CORS to allow frontend domain
   - Restrict to necessary HTTP methods

---

## Performance Optimization

1. **Image Processing**:
   - Resize images before upload (optional)
   - Generate thumbnails for galleries
   - Compress images to reduce storage costs

2. **CDN Integration** (Future):
   - Use Linode's CDN or Cloudflare
   - Cache images at edge locations
   - Reduce latency for global users

3. **Lazy Loading**:
   - Implement lazy loading for gallery images
   - Use placeholder images while loading

---

## Cost Estimation

**Linode Object Storage Pricing** (as of 2026):
- Storage: ~$5/TB/month
- Transfer: First 1TB free, then $0.005/GB

**Estimated Usage**:
- Average image size: 500KB
- 1000 images = ~500MB storage = $0.0025/month
- Very cost-effective for this use case

---

## Success Criteria

✅ All new image uploads go directly to S3  
✅ Existing base64 images migrated to S3  
✅ No 400 errors from malformed URLs  
✅ Images load faster (no base64 parsing)  
✅ Database size reduced significantly  
✅ Upload progress feedback for users  
✅ Proper error handling and fallbacks  

---

## Timeline Estimate

- **Phase 1 (Backend Setup)**: 2-3 hours
- **Phase 2 (Database Updates)**: 1 hour
- **Phase 3 (Migration Script)**: 2-3 hours
- **Phase 4 (Frontend Updates)**: 3-4 hours
- **Phase 5 (Testing)**: 2-3 hours
- **Phase 6 (Deployment)**: 1-2 hours

**Total**: 11-16 hours

---

## Next Steps

1. Review this plan
2. Confirm S3 bucket is created on Linode
3. Verify bucket permissions and CORS settings
4. Begin Phase 1: Backend Setup
5. Test each phase before proceeding to next

